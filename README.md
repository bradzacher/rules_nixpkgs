# Illustration of a "hub repo" design for rules\_nixpkgs

This only demonstrates the [`nixpkgs_*_repository`][nixpkgs_repository] and
[`nixpkgs_package`][nixpkgs_package] features of rules\_nixpkgs and skips the
language toolchains features such as
[`nixpkgs_cc_configure`][nixpkgs_cc_configure].

[nixpkgs_repository]: https://github.com/tweag/rules_nixpkgs/tree/62d63740061dd94ecee3ec2c0cfc8a7ed409b98c#nixpkgs_local_repository
[nixpkgs_package]: https://github.com/tweag/rules_nixpkgs/#nixpkgs_package
[nixpkgs_cc_configure]: https://github.com/tweag/rules_nixpkgs/#nixpkgs_cc_configure

## Concepts

### Nix Repository

Nix has a notion of a repository, a collection of `.nix` files that contain Nix
expressions defining Nix derivations for various software packages. The most
commonly used repository is the Nix packages collection [nixpkgs][nixpkgs]. The
notion of a repository is more general, but here we will focus on nixpkgs.

A particular instance of a nixpkgs repository can be defined in a few ways,
e.g. as a Git commit hash in the nixpkgs Git repository, as the latest instance
on [Nix channel][nix-channel] such as a stable channel like `nixos-22.11`, or
by a local file containing a Nix expression that defines how to fetch a nixpkgs
collection and amend it with [overlays][nix-overlay] or overrides.

[nixpkgs]: https://github.com/NixOS/nixpkgs
[nix-channel]: https://nixos.wiki/wiki/Nix_channels
[nix-overlay]: https://nixos.org/manual/nixpkgs/stable/#chap-overlays

### Nix Package

A Nix repository defines a set of Nix packages which can be addressed by an
attribute path. Furthermore, users can define custom Nix expressions that
combine and modify Nix packages in a Nix repository to create new packages.

Here we will focus on a Nix package defined by an attribute path into a given
Nix repository.

## API

For the purposes of this illustration rules\_nixpkgs consists of
`rules_nixpkgs_core`, which provides an API to import Nix repositories and Nix
packages. To that end `rules_nixpkgs_core` exposes two module extensions:
* `nix_repo` for Nix repositories.
* `nix_pkg` for Nix packages.

Given the variety of ways in which Nix repositories and packages can be
defined, and the amount of control that a user has, it is not clear how to
define a canonical name for a given Nix repository or package to enable
unification of requested Nix repositories or packages across a Baze module
graph. Instead, this design enables users to name a given import Nix repository
or package and refer to it by that name from within the same Bazel module.

The module extensions expose the following tags. Note, at this stage this is an
illustration and further care will need to be taken for a viable API.

* `nix_repo.version(name, version)`\
  Import a Nix repository from a release channel of the given version.\
  Expose it under the given name within the scope of the requesting module.
* `nix_repo.file(name, file)`\
  Import a Nix repository defined by a given file.\
  Expose it under the given name within the scope of the requesting module.
* `nix_pkg.attr(name, attribute, repository)`\
  Import a Nix package under a given attribute path from the given Nix repository.\
  Expose it under the given name within the scope of the requesting module.

The module extensions invoke the old-fashioned, WORKSPACE-style repository
rules of rules\_nixpkgs to import Nix repositories and Nix packages. To that
end it calculates unique names for the corresponding external workspaces to
avoid collisions across the transitive module graph, and uses a ["hub and
spoke"][hub-and-spoke] or ["hub repo"][hub-repo] for each module extension to
expose them to the user.

[hub-and-spoke]: https://github.com/bazelbuild/bazel/issues/17493
[hub-repo]: https://github.com/bazelbuild/bazel/issues/17048

Without a hub repository users would have to predict the generated unique names
for each generated external workspace and import them explicitly in their
`MODULE.bazel` file using `use_repo`.

### Example usage

For example, module A might request a nixpkgs repository by version and a Nix
package from that repository:

```
# MODULE.bazel
module(name = "module_a", version = "0.1.0")

nix_repo = use_extension("@rules_nixpkgs_core//extensions:repository.bzl", "nix_repo")
nix_repo.version(name = "nixpkgs", version = "21.04")

nix_pkg = use_extension("@rules_nixpkgs_core//extensions:package.bzl", "nix_pkg")
nix_pkg.attr(name = "tool", attribute = "some.tool", repository = "nixpkgs")

...
```

Notice how `nix_pkg.attr` references the imported Nix repository by the name
`nixpkgs`. The `nix_pkg` module extension relays to the hub repository
generated by `nix_repo` under the hood to access the imported Nix repository.

To access the imported Nix package `tool` module A needs to access the hub
repository generated by `nix_pkg`:

```
# MODULE.bazel
...

use_repo(nix_pkg, "nixpkgs_packages")
```

That hub repository exposes a macro `get_pkg` that can be called from BUILD
files to obtain targets in the generated external workspace.

```
# BUILD.bazel
load("@nixpkgs_packages//:defs.bzl", "get_pkg")

genrule(
    ...
    tools = [get_pkg(name = "tool", label = "//:bin")],
)
```

### Roadblocks

Unfortunately, the above API is not currently possible to implement. The
problem is that we need to maintain a mapping of which modules requested which
tags from module extensions to macros invoked in BUILD files. Module extensions
know which Bazel modules requested which tags, but, as of now, macros have no
way of determining which Bazel module they were invoked from.

To address this short-coming the user will have to pass the name of the
requesting module manually to the `get_pkg` macro.

```
# BUILD.bazel
load("@nixpkgs_packages//:defs.bzl", "get_pkg")

genrule(
    ...
    tools = [get_pkg(
        module_name = "module_a",  # !!!
        name = "tool",
        label = "//:bin",
    )],
)
```

This is inconvenient.

Unfortunately, it is also insufficient: A module name is not a unique
identifier for an instance of a module. Bazel supports [multi version
overrides][multi-version-overrides], which allow users to have two different
versions of the same module co-exist in the transitive module graph.
The `get_pkg` macro could be extended to take the module version as well to
resolve ambiguity:

[multi-version-overrides]: https://bazel.build/external/module#multiple-version_override

```
# BUILD.bazel
load("@nixpkgs_packages//:defs.bzl", "get_pkg")

genrule(
    ...
    tools = [get_pkg(
        module_name = "module_a",  # !!!
        module_version = "0.1.0",  # !!!
        name = "tool",
        label = "//:bin",
    )],
)
```

Furthermore, Bazel supports [repository mappings][repository-mappings] which
allow to assign a different name to a given module within the scope of another
module. This may introduce further difficulty in tracking module identity
between module extension and macro.

[repository-mappings]: https://bazel.build/external/overview#apparent_repository_name

### Possible solution

A solution to this problem could be an API exposed by Bazel to uniquely
identify modules across module extensions and macros, as requested in
[#17652][bazel-17652].

[bazel-17652]: https://github.com/bazelbuild/bazel/issues/17652

## Demonstration

This repository contains a demonstration of the rules\_nixpkgs outlined in this
document. You can build the project using the following commands:

```
$ cd root
$ bazel build //:generated
```

The demonstration consists of Bazel modules with the following dependency
graph:\
<img width="50%" src="assets/module_deps.svg" alt="module dependency graph">

The `root` module is the top-level module and represents a user project
depending on rules\_nixkpgs transitively. The module `rules_nixpkgs_core`
defines the module extensions described above.

The module `transitive` appears twice in the dependency graph and illustrates
the case of a multi-version-override. The two versions of `transitive` use the
following module extension tags from `rules_nixpkgs_core`:\
<img width="100%" src="assets/transitive_tags.svg" alt="tags requested by transitive">

Each of the transitive modules uses the imported `tool` to generate a file as
follows:

```
load("@nixpkgs_packages//:defs.bzl", "get_pkg")

genrule(
    name = "generated",
    srcs = [get_pkg(
        module_name = "transitive",
        module_version = "2.1.4",
        name = "tool",
        label = "//:package",
    )],
    outs = ["generated.out"],
    cmd = """\
echo 'generated by transitive 2.1.4 with' > $(OUTS)
cat $(SRCS) >> $(OUTS)
""",
    visibility = ["//visibility:public"],
)
```

The modules `direct_a` and `direct_b` use the file generated by their
corresponding version of `transitive`, and finally `root` combines all files
together as follows:

```
genrule(
    name = "generated",
    srcs = [
        "@direct_a//:generated",
        "@direct_b//:generated",
    ],
    outs = ["generated.out"],
    cmd = """\
echo 'generated by root 1.3.7 with' > $(OUTS)
echo '--------------------------------------------------' >> $(OUTS)
for src in $(SRCS); do
    cat $$src >> $(OUTS)
    echo '--------------------------------------------------' >> $(OUTS)
done
""",
    visibility = ["//visibility:public"],
)
```

These `genrule`s are just used for illustration and aren't meaningful
themselves.

The final build result looks like this:

```
$ cat bazel-bin/generated.out
generated by root 1.3.7 with
--------------------------------------------------
generated by direct_a 1.2.5 with
generated by transitive 1.1.3 in external_workspace with
attribute tool_only_in_21.04 from repository @@rules_nixpkgs_core~1.0.1~nix_repo~transitive_nixpkgs//:repository defined as
version 21.04
--------------------------------------------------
generated by direct_b 1.2.6 with
generated by transitive 2.1.4 with
attribute tool_only_in_patched from repository @@rules_nixpkgs_core~1.0.1~nix_repo~transitive_nixpkgs_1//:repository defined as
file @@transitive~2.1.4//:patched_22_11.nix with content
patched version of nixpkgs 22.11
--------------------------------------------------
```

It illustrates how the correct versions of the Nix packages imported by the
different versions of `transitive` were used each time.

## Implementation

The module extensions are implemented under `rules_nixpkgs_core/extensions`:

* [`repo.bzl`](rules_nixpkgs_core/extensions/repo.bzl) defines `nix_repo`, and
* [`pkg.bzl`](rules_nixpkgs_core/extensions/pkg.bzl) defines `nix_pkg`.

Both invoke repository rules defined under `rules_nixpkgs_core/repositories`:

* [`repository.bzl`](rules_nixpkgs_core/repositories/repository.bzl) defines
  `nixpkgs_repository` which is a placeholder for the actual
  `nixpkgs_local_repository` and `nixpkgs_git_repository` in rules\_nixpkgs,
  and
* [`package.bzl`](rules_nixpkgs_core/repositories/package.bzl) defines
  `nixpkgs_package` which is a placeholder for the actual `nixpkgs_package` in
  rules\_nixpkgs.

Each module extension also generates a hub module with the help of the
utilities and the repository rule implemented in
[`rules_nixpkgs_core/private/extensions/registry.bzl`](rules_nixpkgs_core/private/extensions/registry.bzl).
